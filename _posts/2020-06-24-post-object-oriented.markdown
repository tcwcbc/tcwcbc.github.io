---
title:  "객체지향의 사실과 오해(2-2)"
excerpt: "객체지향의 사실과 오해 - 이상한 나라의 객체"
header:
  teaser: /assets/images/object-oriented-cover.jpeg

categories:
  - study
tags:
  - domain
  - object
  
last_modified_at: 2020-06-24T12:00:00+09:00
---
### p.57
객체가 식별 가능하다는 것은 객체를 서로 구별할 수 있는 특정한 프로퍼티가 객체 안에 존재한다는 것을 의미하는데, 이 프로퍼티를 식별자라고 한다.  
값과 객체의 가장 큰 차이점은 값은 식별자를 가지지 않지만 객체는 식별자를 가진다는 점이다.  
값  
- 숫자, 문자열, 날짜, 시간, 금액 등과 같이 변하지 않는 양을 모델링(불변상태)
- 값의 상태가 같으면 두 인스턴스는 동일한 것으로 판단하고 상태가 다르면 두 인스턴스는 다른 것으로 판단
- 산태를 이용해 두 값이 같은지 판단할 수 있는 성질을 동둥성이라고 하는데, 이렇게 판단할 수 있는 이유는 값의 상태가 변하지 않기 때문이다.

### p.58
객체  
- 객체는 시간에 따라 변경되는 상태를 포함하며, 행동을 통해 상태를 변경한다. (가변상태)
- 두 객체의 상태가 다르더라도 식별자가 같다면 두객체를 같은 객체로 판단할 수 있다.(동등성)
- 식별자란 어떤 객체를 다른 객체와 구분하는 데 사용하는 객체의 프로퍼티다. 값은 식별자를 가지지 않기 때문에 상태를 이용한 동등성 검사를 통해 두 인스턴스를 비교해야 한다. 객체는 상태가 변경될 수 있기 때문에 식별자를 이용한 동일성 검사를 통해 두 인스턴스를 비교할 수 있다.


식별자는 변경될 수 있는가?
```
- 식별자가 어느 시점에 변경된다는 것은 그 속성이 식별자로서 적절하지 않다는 의미일 수도 있다.
- 식별자(객체)는 하나의 도메인 컨텍스트 내에서 유의미하게 사용되고 life-cycle이 가시화된다.
- Bounded Context [Martin Fowler's article](https://martinfowler.com/bliki/BoundedContext.html)
    - 여러 컨텍스트에 걸쳐 객체가 존재하는 경우는 컨텍스트별로 객체를 다른 관점에서 봐야할 필요성이 있다.
    - 만약 여러 컨텍스트를 오가는 상황에서의 식별자가 필요하다면 모든 컨텍스트를 아우르는 식별자가 필요하든지 매핑키로 추적할 수 있다.
- 비즈니스 요구사항에 따라 식별자가 변경되어야 하는 경우 다른 값을 식별자로 고려하거나, 이전 객체는 소멸하고 새로운 객체를 생성하는 것이 올바른 방향이 아닐까.
- ex) 나라는 사람이 한국사람일 때에는 식별자를 주민번호로 갖지만, 미국사람으로 변경되었을 경우에는 사회보장번호를 식별자를 가질 수 있다. 이 때 모든 컨텍스트를 아우르는 식별자 체계를 구축하든지, 도메인 경계를 넘어간 시점으로 부터는 새로운 객체로 인식하든지.
```

### p.59
참조객체, 또는 엔티티는 식별자를 지닌 전통적인 의미의 객체를 가리키는 용어다. 값 객체는 식별자를 가지지 않는 값을 가리키는 용어다.
- 객체는 상태를 가지며 상태는 변경가능하다.
- 객체의 상태를 변경시키는 것은 객체의 행동이다.
- 행동의 결과는 상태에 의존적이며 상태를 이용해 서술할 수 있다.
- 행동의 순서가 실행 결과에 영향을 미친다.
- 객체는 어떤 상태에 있더라도 유일하게 식별 가능하다.

### p.60
객체의 상태를 조회하는 작업을 쿼리(Query)라고 하고 객체의 상태를 변경하는 작업을 명령(Command)이라 한다.


CQRS (Command Query Responsibility Segregation)
[Martin Fowler's article](https://martinfowler.com/bliki/CQRS.html) : [번역본](https://medium.com/@joohotheman/%EB%B2%88%EC%97%AD-%EB%A7%88%ED%8B%B4-%ED%8C%8C%EC%9A%B8%EB%9F%AC-cqrs-%ED%8F%AC%EC%8A%A4%ED%8C%85-245c63bb1e58)
```
- 어떤 객체로의 요청이 어떤 성향인지(조회성인지, 변경성인지) 구분하여 판단이 필요하다. 현재 WMS는 구분이 모호하다.
- 시스템이 커질 수록 해당 요청에 따른 트래픽과 성질에 따라 시스템을 구분할 필요가 생기며, 그에따른 infra 및 적용기술이 달라질 수 있다.
- ex) 현재 재고도메인이라고 하는 redis를 data storage로 사용하는 시스템은 쿼리성 시스템이라 볼 수 있고, WMS ADMIN은 해당 재고에 대한 상태를 변경하는 입고/출고/조정에 대한 요청을 받는 커맨드성 시스템이라 볼 수 있다. 단순히 주문과 재고 도메인의 컨텍스트 매핑을 위한 시스템을 넘어 쿼리성 도메인으로 인식할 수 있다.
```
### p.62
객체 기계에서 사격형 버튼은 상태를 변경하는 명령을, 둥근 버튼은 상태를 조회하는 쿼리를 의미한다는 것을 알 수 있다. 명령과 쿼리는 객체가 외부에 제공하는 행동이다.

### p.64
상태를 먼저 결정하고 행동을 나중에 결정하는 방법은 설계에 나쁜 영향
- 캡슐화의 저해
- 객체를 협력자가 아닌 고립된 섬
- 객체의 재사용성 저하

### p.65
객체는 다른 객체와 협력하기 위해 존재하며 행동이 유일한 협력에 참여하는 방법이다.  
객체지향 설계는 애플리케이션에 필요한 협력을 생각하고 협력에 참여하는 데 필요한 행동을 생각한 후 행동을 수행할 객체를 선택하는 방식으로 수행된다. 이 과정에서 필요한 상태가 결정된다.    
협력 안에서 객체의 행동은 결국 객체가 협력에 참여하면서 완수해야 하는 책임을 의미. 어떤 책임이 필요한가를 결정하는 과정이 전체 설계를 주도하는 방법(책임주도설계)  
  
### p.66
객체지향 세계는 현실세계의 단순한 모방이 아니다. 소프트웨어 상품은 실제 세계의 상품이 하지 못하는 가격 계산과 같은 행동을 스스로 수행할 수 있다.

### p.67
현실 속의 객체와 소프트웨어 객체 사이의 가장 큰 차이점은 현실 속에서는 수동적인 존재가 소프트웨어 객체로 구현될 때는 능동적으로 변한다.  
현실 객체가 가지지 못한 추가적인 능력을 보유하게 된다. (사람이 대신 해주던 것들) 이를 의인화라 한다.  
사실 소프트웨어를 만들고 시스템을 구축하는 이유가 사람이 하던 것들을 시스템에게 위임하고자 하는 목적을 생각한다면, 이러한 의인화가 당연한 것 아닐까?
  
### p.68
소프트웨어 안에 구축되는 객체지향 서계는 현실을 모방한 것이 아니다. 현실의 모습을 조금 참조할 뿐 궁극적인 목적은 현실과 전혀 다른 새로운 세계를 창조하는 것이다. 현실 속의 객체보다 더 많은 특징과 능력을 보유한 객체.

### p.69
은유는 표현적차이 또는 의미적 차이라는 논점에서 관련성이 깊다. 여기서 차이란 소프트웨어에 대해 사람들이 생각하는 모습과 실제 소프트웨어의 표현 사이의 차이를 말한다.  
위에서 언급한 현실 속의 객체와 소프트웨어 객체 사이의 차이점  
소프트웨어 객체에 대한 현실 객체의 은유를 효과적으로 사용할 경우 표현적 차이를 줄일 수 있으며, 이해하기 쉽고 유지보수가 용이한 소프트웨어를 만들 수 있다.  

