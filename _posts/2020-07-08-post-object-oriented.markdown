---
title:  "객체지향의 사실과 오해(3-2)"
excerpt: "객체지향의 사실과 오해 - 타입과 추상화"
header:
  teaser: /assets/images/object-oriented-cover.jpeg

categories:
  - study
tags:
  - domain
  - object
  
last_modified_at: 2020-07-08T12:00:00+09:00
---
### p.97
- `트럼프는 트럼프 인간을 포괄하는 조금 더 일반적인 개념이다. 트럼프 인간은 트럼프보다 좀 더 특화된 행동을 하는 특수한 개념이다. : 일반화/특수화(generalization/specialization)`
- 일반화와 특수화는 동시에 일어난다.


### p.98
- `객체지향에서 일반화/특수화 관계를 결정하는 것은 객체의 상태를 표현하는 데이터가 아니라 행동이라는 것이다.`
- 일반적인 타입이란 특수한 타입이 가진 모든 행동들 중에서 일부 행동만을 가지는 타입을 가리킨다. 특수한 타입이란 일반적인 타임이 가진 모든 타입을 포함하지만 거기에 더해 자신만의 행동을 추가하는 타입을 가리킨다.
- 일반화/특수화는 행동에 관한 것이다.


### p.99
- 일반화/특수화 관계에서 일반적으로 타입은 특수한 타입보다 더 적은 수의 행동을 가지지만 더 큰 크기의 외연 집합을 가진다. 특수한 타입은 일반적인 타입보다 더 많은 수의 행동을 가지지만 더 적은 크기의 외연 집합을 가진다.
- 상속 vs 조합  
```
상속보다 조합을 사용하라고 권장하는데 과연 이유는 무엇일까?    
상속을 했을 경우 코드의 양은 줄어들지만 추상화된 타입이 변경이 되었을 경우 부수효과가 발생하고, 타입을 결정하는 비즈니스 요구사항은 언제든지 변경되기 마련이다. 협력관계의 확장 측면에서 보더라도 조합이 훨씬 유연하다고 판단된다.    
상속이 무조건 나쁘다는 것은 아니지만, 1depth 까지는 뭐... 대신에 추상화 된 부모 클래스의 캡슐화가 엄격하게 구성될 필요가 있다.  
```
- 참고
    - [상속보다 구성을 선호하십니까?](https://c10106.tistory.com/1976)
    - [상속보다 조합을 사용하자.](https://woowacourse.github.io/javable/2020-05-18/inheritance-vs-composition)

- 일반적인 타입을 슈퍼타입, 특수한 타입을 서브타입이라고 한다.
- 두 타입 간의 관계가 행동에 의해 결정된다.


### p.100
- 슈퍼타입의 행동은 서브타입에게 자동으로 상속된다.


### p.101
- 두가지 추상화 기법이 함께 사용
    - 정원에 있던 등장인물들의 차이점은 배제하고 공통점만을 강조함으로써 이들을 공통의 타입인 트럼프 인간으로 분류
    - 트럼프 인간을 좀 더 단순한 관점에서 바라보기 위해 불필요한 특성을 배제하고 좀 더 포괄적인 의미를 지닌 트럼프로 일반화
- 대부분 분류와 일반화/특수화 기법은 동시에 적용하게 된다. 
- 분류는 추상화를 위한 도구이다. => p.88
- 타입을 사용하는 이유는 인간의 인지 능력으로는 시간에 따라 동적으로 변하는 객체의 복잡성를 극복하기가 너무 어렵기 때문이다.


### p.102
- 타입은 시간에 따라 동적으로 변하는 앨리스의 상태를 시간과 무관한 정적인 모습으로 다룰 수 있게 해준다.


### p.103
- `타입은 추상화다. 타입을 이용하면 객체의 동적인 특성을 추상화할 수 있다. 결국 타입은 시간에 따른 객체의 상태 변경이라는 복잡성을 단순화 할 수 있는 효과적인 방법이다.`
- 동적모델과 정적모델
    - `동적모델`
        - 객체가 특정 시점에 구체적으로 어떤 상태를 가지느냐
        - 스냅샷
        - 객체 다이어그램
        - `스냅샷처럼 실제로 객체가 살아 움직이는 동안 상태가 어떻게 변하고 어떤게 행동하는지를 포착하는 것`
    - `정적모델`
        - `객체가 가질 수 있는 모든 상태와 모든 행동을 시간에 독립적으로 표현하는 것`
        - 타입모델
        - 객체가 속한 타입의 정적인 모습을 표현
        

### p.104
- `객체 관점의 동적 모델과 객체를 추상화한 타입 관점의 정적 모델을 적절히 혼용해야 한다.`
    - `클래스를 작성하는 시점에는 시스템을 정적인 관접에서 접근`
    - `애플리케이션을 실행해 객체의 상태 변경을 추적하고 디버깅하는 동안에는 객체의 동적인 모델을 탐험`
```
보통 서비스를 운영하는 개발자는 객체나 데이터의 라이프사이클을 확인 및 추적하는 일이 잦다. 이러한 동적모델로 시스템을 바라보는 관점이 습관화되어 설계하는 시점에도 적용이 되었을 때, 우리는 행동을 먼저 정의하며 객체를 설계하는 정적 모델 관점이 아닌 상태 위주로 바라보는 동적 모델 관점에서 설계하기 쉽다.
```

- 정적인 모델은 클래스를 이용해 구현된다
- 클래스와 타입은 동일한 것이 아니다. 타입은 객체를 분류하기 위해 사용하는 개념이다. 반면 클래스는 단지 타입을 구현할 수 있는 여러 구현 매커니즘 중 하나일 뿐이다.
- `클래스와 타입을 구분하는 것은 설계를 유연하게 유지하기 위한 바탕이 된다. 클래스는 타입의 구현 외에도 코드를 재사용하는 용도로도 사용되기 때문에 클래스와 타입을 동일시 하는 것은 수많은 오해와 혼란을 불러일으키곤 한다.`
```
엔터프라이즈급 시스템(흔히 프레임웍을 사용하는)에서는 사실상 타입의 구현 외에도 많은 용도로 클래스를 사용하고 있다. presentation layer, persistence layer, configuration, utility 등에서도 클래스를 활용하고 있음을 인지할 필요가 있다.
```


### p.105
- 객체를 분류하는 기준은 타입이며, 타입을 나누는 기준은 객체가 수행하는 행동이다. 객체를 분류하기 위해 타입을 결정한 후 프로그래밍 언어를 이용해 타입을 구현할 수 있는 한 가지 방법이 클래스라는 사실을 아는 것은 중요하다
- `객체지향에서 중요한 것은 동적으로 변하는 객체의 상태와 상태를 변경하는 행위다. 클래스는 타입을 구현하기 위해 프로그래밍 언어에서 제공하는 구현 매커니즘이다.`